diff --git a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
index 5035624..e45a27e 100644
--- a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
+++ b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
@@ -258,9 +258,26 @@ class cl_eye_P : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 1);
 	}
 };
-
 static cl_eye_P binder_eye_P;
 
+// interpolated eye position (crookr scope parallax)
+// We can improve this by clamping the magnitude of the travel here instead of in-shader. 
+// it would fix the issue with the fog "sticking" when moving too far off center
+extern float scope_fog_interp;
+extern float scope_fog_travel;
+class cl_eye_PL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraPosition;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 1);
+	}
+};
+static cl_eye_PL binder_eye_PL;
+
 // eye-params
 class cl_eye_D : public R_constant_setup
 {
@@ -270,9 +287,22 @@ class cl_eye_D : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 0);
 	}
 };
-
 static cl_eye_D binder_eye_D;
 
+// interpolated eye direction (crookr scope parallax)
+class cl_eye_DL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraDirection;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 0);
+	}
+};
+static cl_eye_DL binder_eye_DL;
+
 // eye-params
 class cl_eye_N : public R_constant_setup
 {
@@ -285,6 +315,47 @@ class cl_eye_N : public R_constant_setup
 
 static cl_eye_N binder_eye_N;
 
+
+// fake scope params (crookr)
+extern float scope_outerblur;
+extern float scope_innerblur;
+extern float scope_scrollpower;
+extern float scope_brightness;
+class cl_fakescope_params : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_scrollpower, scope_innerblur, scope_outerblur, scope_brightness);
+	}
+};
+static cl_fakescope_params binder_fakescope_params;
+
+extern float scope_ca;
+extern float scope_fog_attack;
+extern float scope_fog_mattack;
+//extern float scope_fog_travel;
+class cl_fakescope_ca : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_ca, scope_fog_attack, scope_fog_mattack, scope_fog_travel);
+	}
+};
+static cl_fakescope_ca binder_fakescope_ca;
+
+extern float scope_radius;
+extern float scope_fog_radius;
+extern float scope_fog_sharp;
+//extern float scope_drift_amount;
+class cl_fakescope_params3 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_radius, scope_fog_radius, scope_fog_sharp, 0.0f);
+	}
+};
+static cl_fakescope_params3 binder_fakescope_params3;
+
 #ifndef _EDITOR
 // D-Light0
 class cl_sun0_color : public R_constant_setup
@@ -639,7 +710,9 @@ void CBlender_Compile::SetMapping()
 
 	// eye-params
 	r_Constant("eye_position", &binder_eye_P);
+	r_Constant("eye_position_lerp", &binder_eye_PL); // crookr
 	r_Constant("eye_direction", &binder_eye_D);
+	r_Constant("eye_direction_lerp", &binder_eye_DL); // crookr
 	r_Constant("eye_normal", &binder_eye_N);
 
 #ifndef _EDITOR
@@ -690,6 +763,11 @@ void CBlender_Compile::SetMapping()
 	r_Constant("shader_param_7", &dev_param_7);
 	r_Constant("shader_param_8", &dev_param_8);
 
+	// crookr
+	r_Constant("fakescope_params1", &binder_fakescope_params);
+	r_Constant("fakescope_params2", &binder_fakescope_ca);
+	r_Constant("fakescope_params3", &binder_fakescope_params3);
+
 	// other common
 	for (u32 it = 0; it < DEV->v_constant_setup.size(); it++)
 	{
diff --git a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
index 248d1c4..2935515 100644
--- a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
+++ b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
@@ -51,3 +51,57 @@ void CRenderTarget::phase_nightvision()
 	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
 #endif
 };
+
+
+//crookr
+void CRenderTarget::phase_fakescope()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+#if defined(USE_DX10) || defined(USE_DX11)	
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+#else
+	p0.set(0.5f / w, 0.5f / h);
+	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
+#endif
+
+	//////////////////////////////////////////////////////////////////////////
+	//Set MSAA/NonMSAA rendertarget
+#if defined(USE_DX10) || defined(USE_DX11)
+	ref_rt& dest_rt = RImplementation.o.dx10_msaa ? rt_Generic : rt_Color;
+	u_setrt(dest_rt, nullptr, nullptr, nullptr);
+#else
+	u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+#endif		
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_fakescope->E[ps_r2_nightvision]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+#if defined(USE_DX10) || defined(USE_DX11)
+	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
+#endif
+};
\ No newline at end of file
diff --git a/src/Layers/xrRender/xrRender_console.cpp b/src/Layers/xrRender/xrRender_console.cpp
index 19cf561..9653bb5 100644
--- a/src/Layers/xrRender/xrRender_console.cpp
+++ b/src/Layers/xrRender/xrRender_console.cpp
@@ -258,6 +258,10 @@ Fvector ps_r2_drops_control = {.0f, 1.15f, .0f}; // r2-only
 
 int ps_r2_nightvision = 0;
 
+//crookr
+int scope_fake_enabled = 1;
+//string32 scope_fake_texture = "wpn\\wpn_crosshair_pso1";
+
 float ps_r2_ss_sunshafts_length = 1.f;
 float ps_r2_ss_sunshafts_radius = 1.f;
 
@@ -1046,6 +1050,9 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "r__bloom_weight", &ps_pp_bloom_weight, twb_min, twb_max);
 	CMD4(CCC_Vector4, "r__bloom_thresh", &ps_pp_bloom_thresh, twb_min, twb_max);
 	CMD4(CCC_Integer, "r__nightvision", &ps_r2_nightvision, 0, 3); //For beef's nightvision shader or other stuff
+
+	CMD4(CCC_Integer, "r__fakescope", &scope_fake_enabled, 0, 1); //crookr for fake scope
+
 	CMD3(CCC_Mask, "r2_terrain_z_prepass", &ps_r2_ls_flags, R2FLAG_TERRAIN_PREPASS); //Terrain Z Prepass @Zagolski
 	
 	//////////other
diff --git a/src/Layers/xrRender/xrRender_console.h b/src/Layers/xrRender/xrRender_console.h
index 7ee8c11..84a2c7f 100644
--- a/src/Layers/xrRender/xrRender_console.h
+++ b/src/Layers/xrRender/xrRender_console.h
@@ -140,6 +140,7 @@ extern ECORE_API int ps_r2_qsync;
 extern ECORE_API Fvector4 ps_r2_mask_control; // r2-only
 extern ECORE_API Fvector ps_r2_drops_control; // r2-only
 extern ECORE_API int ps_r2_nightvision;
+extern ECORE_API int scope_fake_enabled; //crookr
 extern ECORE_API float ps_r2_ss_sunshafts_length;
 extern ECORE_API float ps_r2_ss_sunshafts_radius;
 extern u32 ps_sunshafts_mode;
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
index b44403b..baff94d 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
@@ -3,10 +3,14 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
 
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
@@ -38,3 +42,12 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;	
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+	C.r_Pass("null", "fakescope", FALSE, FALSE, FALSE);
+	C.r_Sampler_rtf("s_position", r2_RT_P);
+	C.r_Sampler_clf("s_image", r2_RT_generic0);
+	C.r_End();
+}
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.h b/src/Layers/xrRenderPC_R2/blender_nightvision.h
index 0801e41..05189e8 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.h
@@ -13,3 +13,17 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
index f55c506..5ec5666 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
@@ -247,6 +247,7 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -288,6 +289,7 @@ CRenderTarget::CRenderTarget()
 		rt_secondVP.create(r2_RT_secondVP, w, h, D3DFMT_A8R8G8B8); //--#SM+#-- +SecondVP+
 		rt_ui_pda.create(r2_RT_ui, w, h, D3DFMT_A8R8G8B8);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
 
 		// RT Blur
 		rt_blur_h_2.create(r2_RT_blur_h_2, u32(w/2), u32(h/2), D3DFMT_A8R8G8B8);
@@ -323,6 +325,7 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -758,6 +761,7 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.h b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
index 727029d..f75ff50 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.h
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
@@ -39,6 +39,7 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -68,6 +69,8 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+	ref_rt rt_fakescope; //crookr
+
 	ref_rt rt_dof;
 	
 	ref_rt rt_blur_h_2;
@@ -122,6 +125,7 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
 
 	ref_shader s_blur;	
 	ref_shader s_dof;
@@ -260,6 +264,7 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
 	void phase_lut();	
 	void phase_smaa();
 		
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
index bbec49c..443c2c0 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
@@ -276,6 +276,11 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/Layers/xrRenderPC_R2/r2_types.h b/src/Layers/xrRenderPC_R2/r2_types.h
index 7033e17..345b8a0 100644
--- a/src/Layers/xrRenderPC_R2/r2_types.h
+++ b/src/Layers/xrRenderPC_R2/r2_types.h
@@ -62,6 +62,8 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
index 1a5d5c6..8ffed7b 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
@@ -3,11 +3,16 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -66,3 +71,22 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.h b/src/Layers/xrRenderPC_R3/blender_nightvision.h
index 0801e41..05189e8 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.h
@@ -13,3 +13,17 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R3/r2_types.h b/src/Layers/xrRenderPC_R3/r2_types.h
index 6597231..2e7dd84 100644
--- a/src/Layers/xrRenderPC_R3/r2_types.h
+++ b/src/Layers/xrRenderPC_R3/r2_types.h
@@ -70,6 +70,8 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
index 9c5ecf2..0ff83e9 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
@@ -351,6 +351,7 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -430,6 +431,8 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -477,6 +480,7 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1143,6 +1147,7 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.h b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
index 6d332ba..f097ef4 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.h
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
@@ -58,6 +58,7 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -93,6 +94,9 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+
+	ref_rt rt_fakescope; //crookr
+	
 	ref_rt rt_dof;
 
 	ref_rt rt_blur_h_2;
@@ -171,6 +175,7 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
 	ref_shader s_lut;	
 
     ref_shader s_smaa;
@@ -298,6 +303,7 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
 	void phase_lut();	
 	void phase_smaa();	
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
index fe27772..f7576be 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
@@ -396,6 +396,11 @@ void CRenderTarget::phase_combine()
 	
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
+
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
 	
     //SMAA
 	if (ps_smaa_quality)
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
index 1a5d5c6..a13b7fa 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
@@ -3,11 +3,17 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -66,3 +72,26 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+	//C.r_dx10Texture("s_scope", "wpn\\wpn_crosshair_pso1");
+	//C.r_dx10Texture("s_scope", scope_fake_texture);
+	C.r_dx10Texture("s_scope", r2_RT_scopert);
+
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.h b/src/Layers/xrRenderPC_R4/blender_nightvision.h
index 0801e41..e65607f 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.h
@@ -13,3 +13,17 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
diff --git a/src/Layers/xrRenderPC_R4/r2_types.h b/src/Layers/xrRenderPC_R4/r2_types.h
index 18a11d4..54866bd 100644
--- a/src/Layers/xrRenderPC_R4/r2_types.h
+++ b/src/Layers/xrRenderPC_R4/r2_types.h
@@ -69,6 +69,8 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
index 4280e5f..a0d7fbb 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
@@ -350,6 +350,7 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -434,6 +435,9 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -479,6 +483,9 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1156,6 +1163,7 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.h b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
index 37da92e..05dc919 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.h
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
@@ -58,6 +58,7 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
 	IBlender* b_lut;
 	IBlender* b_smaa;
 	// compute shader for hdao
@@ -95,6 +96,9 @@ public:
 	
 	ref_rt rt_secondVP;	// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 
+
+	ref_rt rt_fakescope;	// crookr fakescope
+
 	ref_rt rt_dof;
 	ref_rt rt_ui_pda;
 	
@@ -174,7 +178,8 @@ private:
 	ref_shader s_pp_bloom;	
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
-	ref_shader s_nightvision;	
+	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
 	ref_shader s_smaa;
 
 	ref_shader s_lut;
@@ -300,6 +305,7 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
 	void phase_lut();		
 	void phase_smaa();
 	void phase_scene_prepare();
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
index 875ae48..a5e8ac1 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
@@ -396,6 +396,11 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..4aa560a 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -596,6 +596,21 @@ public:
 	}
 };
 
+extern void updateCurrentScope();
+class CCC_ScopeFactor : public CCC_Float
+{
+public:
+	CCC_ScopeFactor(LPCSTR N, float* V) : CCC_Float(N, V, 0.01f, 1.0f)
+	{
+	}
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Float::Execute(args);
+		updateCurrentScope();
+	}
+};
+
 //-----------------------------------------------------------------------
 /*
 #ifdef DEBUG
@@ -864,6 +879,22 @@ Ivector4 g_crosshair_color_temp;
 float g_freelook_z_offset;
 float g_ironsights_factor = 1.25f;
 
+// crookr fake scope params (sorry)
+float scope_fog_interp = 0.15f;
+float scope_fog_travel = 0.25f;
+float scope_fog_attack = 0.66f;
+float scope_fog_mattack = 0.25f;
+//float scope_drift_amount = 1.f;
+float scope_ca = 0.003f;
+float scope_outerblur = 1.0f;
+float scope_innerblur = 0.1f;
+float scope_scrollpower = 0.66f;
+float scope_brightness = 1.0f;
+float scope_radius = 0.f;
+float scope_fog_radius = 1.25f;
+float scope_fog_sharp = 4.0f;
+int scope_2dtexactive = 0.0;
+
 void CCC_Register()
 {
 	// General
@@ -1024,6 +1055,24 @@ void CCC_Register()
 
 	CMD4(CCC_Float, "g_ironsights_zoom_factor", &g_ironsights_factor, 1.f, 2.f);
 	
+	// - CrookR
+	CMD2(CCC_Float, "scope_blur_outer", &scope_outerblur);
+	CMD2(CCC_Float, "scope_blur_inner", &scope_innerblur);
+	CMD2(CCC_ScopeFactor, "scope_factor", &scope_scrollpower);
+	CMD2(CCC_Float, "scope_brightness", &scope_brightness);
+
+	CMD2(CCC_Float, "scope_fog_interp", &scope_fog_interp);
+	CMD4(CCC_Float, "scope_fog_travel", &scope_fog_travel, 0.f, 5.f);
+	CMD4(CCC_Float, "scope_fog_swayAim", &scope_fog_attack, -999.f, 999.f);
+	CMD4(CCC_Float, "scope_fog_swayMove", &scope_fog_mattack, -999.f, 999.f);
+	//CMD4(CCC_Float, "scope_drift_amount", &scope_drift_amount, -999.f, 999.f);
+
+	CMD2(CCC_Float, "scope_ca", &scope_ca);
+	CMD4(CCC_Float, "scope_radius", &scope_radius, 0, 2);
+	CMD4(CCC_Float, "scope_fog_radius", &scope_fog_radius, 0, 1000);
+	CMD4(CCC_Float, "scope_fog_sharp", &scope_fog_sharp, 0, 1000);
+	CMD2(CCC_Integer, "scope_2dtexactive", &scope_2dtexactive);
+
 #ifdef DEBUG
     extern BOOL debug_destroy;
     CMD4(CCC_Integer, "debug_destroy", &debug_destroy, FALSE, TRUE);
diff --git a/src/xrGame/ActorInput.cpp b/src/xrGame/ActorInput.cpp
index 8499334..48becf2 100644
--- a/src/xrGame/ActorInput.cpp
+++ b/src/xrGame/ActorInput.cpp
@@ -433,7 +433,7 @@ void CActor::IR_OnMouseMove(int dx, int dy)
 	float LookFactor = GetLookFactor();
 
 	CCameraBase* C = cameras[cam_active];
-	float scale = (C->f_fov / g_fov) * psMouseSens * psMouseSensScale / 50.f / LookFactor;
+    float scale = (C->f_fov / g_fov) * (psMouseSens * sens_multiple) * psMouseSensScale / 50.f / LookFactor;
 	if (dx)
 	{
 		float d = float(dx) * scale;
diff --git a/src/xrGame/NewZoomFlag.h b/src/xrGame/NewZoomFlag.h
new file mode 100644
index 0000000..ec29839
--- /dev/null
+++ b/src/xrGame/NewZoomFlag.h
@@ -0,0 +1,13 @@
+#pragma once
+//New_zoom
+enum
+{
+	NEW_ZOOM = (1 << 0),
+	SDS_ZOOM = (1 << 1),
+	SDS_SPEED = (1 << 3),
+	SDS = (1 << 4),
+
+};
+
+extern Flags32 zoomFlags;
+//
\ No newline at end of file
diff --git a/src/xrGame/Weapon.cpp b/src/xrGame/Weapon.cpp
index 080f84d..e55870c 100644
--- a/src/xrGame/Weapon.cpp
+++ b/src/xrGame/Weapon.cpp
@@ -42,6 +42,47 @@
 float f_weapon_deterioration = 1.0f;
 extern CUIXml* pWpnScopeXml;
 
+//////////
+extern float scope_radius;
+
+Flags32 zoomFlags = {};
+extern float n_zoom_step_count;
+float sens_multiple = 1.0f;
+
+
+float CWeapon::SDS_Radius(bool alt) {
+	shared_str scope_tex_name;
+	if (m_zoomtype == 0 && zoomFlags.test(SDS))
+	{
+		if (0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			scope_tex_name = pSettings->r_string(GetScopeName(), alt ? "scope_texture_alt" : "scope_texture");
+		}
+		else
+		{
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), alt ? "scope_texture_alt" : "scope_texture", NULL);
+		}
+
+		if (scope_tex_name != 0) {
+			auto item = listScopeRadii.find(scope_tex_name);
+			if (item != listScopeRadii.end()) {
+				return item->second;
+			}
+			else {
+				return 0.0;
+			}
+		}
+		else {
+			return 0.0;
+		}
+	}
+	else {
+		return 0.0;
+	}
+}
+
+//////////
+
 CWeapon::CWeapon()
 {
 	SetState(eHidden);
@@ -103,6 +144,7 @@ CWeapon::CWeapon()
 	//PP.RQ.set(NULL, 0.f, -1);
 }
 
+extern int scope_2dtexactive; //crookr
 CWeapon::~CWeapon()
 {
 	xr_delete(m_UIScope);
@@ -218,8 +260,32 @@ void CWeapon::UpdateFireDependencies_internal()
 	}
 }
 
-void CWeapon::UpdateUIScope()
-{
+void updateCurrentScope() {
+	if (!g_pGameLevel) return;
+
+	CInventoryOwner* pGameObject = smart_cast<CInventoryOwner*>(Level().Objects.net_Find(0));
+	if (pGameObject) {
+		if (pGameObject->inventory().ActiveItem()) {
+			CWeapon* weapon = smart_cast<CWeapon*>(pGameObject->inventory().ActiveItem());
+			if (weapon) {
+				weapon->UpdateZoomParams();
+			}
+		}
+	}
+}
+
+void CWeapon::UpdateZoomParams() {
+	//////////
+	m_zoom_params.m_fMinBaseZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "min_scope_zoom_factor", 200.0f);
+
+
+	float zoom_multiple = 1.0f;
+	if (zoomFlags.test(SDS_ZOOM) && (SDS_Radius() > 0.0)) {
+		zoom_multiple = scope_scrollpower;
+	}
+
+	//////////
+
 	// Load scopes.xml if it's not loaded
 	if (pWpnScopeXml == nullptr)
 	{
@@ -230,30 +296,47 @@ void CWeapon::UpdateUIScope()
 	// update zoom factor
 	if (m_zoomtype == 2) //GL
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_GL || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_gl", false);
 		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[1] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "gl_zoom_factor", 0);
-	}
-	else if (m_zoomtype == 1) //Alt
+	} else if (m_zoomtype == 1) //Alt
 	{
-		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0);
-	}
-	else //Main Sight
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
+		m_zoom_params.m_fScopeZoomFactor = (g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0)) / (READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture_alt", NULL) && zoomFlags.test(SDS_ZOOM) && (SDS_Radius(true) > 0.0) ? zoom_multiple : 1);
+	} else //Main Sight
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 		if (g_player_hud->m_adjust_mode)
 		{
-			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0];
-		}
-		else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0] / zoom_multiple;
+		} else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
 		{
-			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor");
-		}
-		else
+			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor") / zoom_multiple;
+		} else
 		{
-			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor;
+			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor / zoom_multiple;
 		}
 	}
 
-	if (IsZoomed())
-		m_zoom_params.m_fCurrentZoomFactor = m_zoom_params.m_fScopeZoomFactor;
+	if (IsZoomed()) {
+		scope_radius = SDS_Radius();
+		if (m_zoomtype == 0 && zoomFlags.test(SDS_SPEED) && (scope_radius > 0.0)) {
+			sens_multiple = scope_scrollpower;
+		} else {
+			sens_multiple = 1.0f;
+		}
+
+
+		if (m_zoom_params.m_bUseDynamicZoom) {
+			SetZoomFactor(m_fRTZoomFactor / zoom_multiple);
+		} else {
+			SetZoomFactor(m_zoom_params.m_fScopeZoomFactor);
+		}
+	}
+}
+
+void CWeapon::UpdateUIScope()
+{
+	UpdateZoomParams();
 
 	// Change or remove scope texture
 	shared_str scope_tex_name;
@@ -276,6 +359,7 @@ void CWeapon::UpdateUIScope()
 	if (!g_dedicated_server)
 	{
 		xr_delete(m_UIScope);
+		scope_2dtexactive = 0; //crookr
 
 		if (!scope_tex_name || scope_tex_name.equal("none") || g_player_hud->m_adjust_mode)
 			return;
@@ -290,6 +374,7 @@ void CWeapon::SwitchZoomType()
 	if (m_zoomtype == 0 && (m_altAimPos || g_player_hud->m_adjust_mode))
 	{
 		m_zoomtype = 1;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
 	}
 	else if (IsGrenadeLauncherAttached())
 	{
@@ -299,6 +384,7 @@ void CWeapon::SwitchZoomType()
 	else if (m_zoomtype != 0)
 	{
 		m_zoomtype = 0;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 	}
 
 	UpdateUIScope();
@@ -1616,11 +1702,22 @@ float CWeapon::CurrentZoomFactor()
 
 void CWeapon::OnZoomIn()
 {
+    //////////
+    scope_radius = SDS_Radius();
+
+	if ((scope_radius > 0.0) && zoomFlags.test(SDS_SPEED)) {
+		sens_multiple = scope_scrollpower;
+	}
+	else {
+		sens_multiple = 1.0f;
+	}
+    //////////
+    
 	m_zoom_params.m_bIsZoomModeNow = true;
 	if (m_zoom_params.m_bUseDynamicZoom)
-		SetZoomFactor(m_fRTZoomFactor);
+		SetZoomFactor(scope_radius > 0.0 ? m_fRTZoomFactor / scope_scrollpower : m_fRTZoomFactor);
 	else
-		m_zoom_params.m_fCurrentZoomFactor = CurrentZoomFactor();
+		SetZoomFactor(CurrentZoomFactor());
 
 	if (m_zoom_params.m_bZoomDofEnabled && !IsScopeAttached())
 		GamePersistent().SetEffectorDOF(m_zoom_params.m_ZoomDof);
@@ -1650,7 +1747,11 @@ void CWeapon::OnZoomIn()
 void CWeapon::OnZoomOut()
 {
 	m_zoom_params.m_bIsZoomModeNow = false;
-	m_fRTZoomFactor = GetZoomFactor(); //store current
+    if (m_zoom_params.m_bUseDynamicZoom)
+    {
+        m_fRTZoomFactor = scope_radius > 0.0 ? GetZoomFactor() * scope_scrollpower : GetZoomFactor(); //store current
+    }
+    
 	m_zoom_params.m_fCurrentZoomFactor = g_fov;
 
 	GamePersistent().RestoreEffectorDOF();
@@ -1668,6 +1769,11 @@ void CWeapon::OnZoomOut()
 	}
 
 	g_player_hud->updateMovementLayerState();
+    
+    scope_radius = 0.0;
+    scope_2dtexactive = 0;
+    sens_multiple = 1.0f;
+
 }
 
 CUIWindow* CWeapon::ZoomTexture()
@@ -1675,7 +1781,10 @@ CUIWindow* CWeapon::ZoomTexture()
 	if (UseScopeTexture())
 		return m_UIScope;
 	else
+	{
+		scope_2dtexactive = 0; //crookr
 		return NULL;
+	}
 }
 
 void CWeapon::SwitchState(u32 S)
@@ -2516,6 +2625,9 @@ void CWeapon::render_item_ui()
 
 	ZoomTexture()->Update();
 	ZoomTexture()->Draw();
+
+	//crookr
+	scope_2dtexactive = ZoomTexture()->IsShown() ? 1 : 0;
 }
 
 bool CWeapon::unlimited_ammo()
@@ -2697,16 +2809,44 @@ bool CWeapon::IsHudModeNow()
 	return (HudItemData() != NULL);
 }
 
+void NewGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float zoom, float min_zoom)
+{
+	
+	float def_fov = float(g_fov);
+	float min_zoom_k = 0.3f;
+	float delta_factor_total = def_fov - scope_factor;
+	VERIFY(delta_factor_total > 0);
+	float loc_min_zoom_factor = (atan(tan(def_fov * (0.5 * PI / 180)) / g_ironsights_factor) / (0.5 * PI / 180)) / 0.75f;
+
+	if (min_zoom < loc_min_zoom_factor) {
+		min_zoom_factor = min_zoom;
+	}
+	else {
+		min_zoom_factor = loc_min_zoom_factor;
+	}
+
+	delta = ((delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count) * (zoom / def_fov);
+}
+
 void CWeapon::ZoomInc()
 {
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() - delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power - delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 void CWeapon::ZoomDec()
@@ -2714,11 +2854,20 @@ void CWeapon::ZoomDec()
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() + delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power + delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 u32 CWeapon::Cost() const
diff --git a/src/xrGame/Weapon.h b/src/xrGame/Weapon.h
index 9880065..dc01e6b 100644
--- a/src/xrGame/Weapon.h
+++ b/src/xrGame/Weapon.h
@@ -14,6 +14,8 @@
 
 #include "CameraRecoil.h"
 
+#include "NewZoomFlag.h"
+
 class CEntity;
 class ENGINE_API CMotionDef;
 class CSE_ALifeItemWeapon;
@@ -26,6 +28,11 @@ class CNightVisionEffector;
 
 extern float f_weapon_deterioration;
 
+extern std::map<shared_str, float> listScopeRadii;
+
+extern float scope_scrollpower;
+extern float sens_multiple;
+
 struct PickParam
 {
 	collide::rq_result RQ;
@@ -317,6 +324,7 @@ protected:
 
 	struct SZoomParams
 	{
+        float m_fMinBaseZoomFactor;
 		bool m_bZoomEnabled;
 		bool m_bHideCrosshairInZoom;
 		bool m_bZoomDofEnabled;
@@ -331,6 +339,9 @@ protected:
 		Fvector4 m_ReloadDof;
 		Fvector4 m_ReloadEmptyDof; //Swartz: reload when empty mag. DOF
 		BOOL m_bUseDynamicZoom;
+		BOOL m_bUseDynamicZoom_Primary;
+		BOOL m_bUseDynamicZoom_Alt;
+		BOOL m_bUseDynamicZoom_GL;
 		shared_str m_sUseZoomPostprocess;
 		shared_str m_sUseBinocularVision;
 		CBinocularsVision* m_pVision;
@@ -452,6 +463,7 @@ public:
 	//virtual collide::rq_result& GetRQ() { return PP.RQ; }
 	//virtual void net_Relcase(CObject* object);
 	Fmatrix m_shoot_shake_mat;
+	void UpdateZoomParams();
 
 protected:
 	virtual void UpdateFireDependencies_internal();
@@ -878,4 +890,6 @@ public:
 	{
 		return cNameSect();
 	};
+    
+    float SDS_Radius(bool alt = false);
 };
diff --git a/src/xrGame/WeaponBinoculars.cpp b/src/xrGame/WeaponBinoculars.cpp
index 21be7d1..768462e 100644
--- a/src/xrGame/WeaponBinoculars.cpp
+++ b/src/xrGame/WeaponBinoculars.cpp
@@ -9,6 +9,9 @@
 #include "object_broker.h"
 #include "inventory.h"
 
+extern float n_zoom_step_count;
+float czoom;
+
 CWeaponBinoculars::CWeaponBinoculars()
 {
 	m_binoc_vision = NULL;
@@ -56,6 +59,7 @@ void CWeaponBinoculars::OnZoomIn()
 		}
 	}
 	inherited::OnZoomIn();
+    SetZoomFactor(czoom);
 }
 
 void CWeaponBinoculars::OnZoomOut()
@@ -75,6 +79,7 @@ void CWeaponBinoculars::OnZoomOut()
 
 BOOL CWeaponBinoculars::net_Spawn(CSE_Abstract* DC)
 {
+    czoom = CWeaponBinoculars::m_zoom_params.m_fScopeZoomFactor;
 	return inherited::net_Spawn(DC);
 }
 
@@ -115,24 +120,36 @@ void GetZoomData(const float scope_factor, float& delta, float& min_zoom_factor)
 	delta = (delta_factor_total * (1 - min_zoom_k)) / zoom_step_count;
 }
 
+void newGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float c_zoom)
+{
+    float def_fov = float(g_fov);
+    float min_zoom_k = 0.3f;
+    float delta_factor_total = def_fov - scope_factor;
+    VERIFY(delta_factor_total > 0);
+    min_zoom_factor = def_fov - delta_factor_total * min_zoom_k;
+    delta = (delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count * (c_zoom / def_fov);
+}
+
 void CWeaponBinoculars::ZoomInc()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() - delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::ZoomDec()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() + delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::save(NET_Packet& output_packet)
diff --git a/src/xrGame/WeaponMagazined.cpp b/src/xrGame/WeaponMagazined.cpp
index b933f2a..6c97431 100644
--- a/src/xrGame/WeaponMagazined.cpp
+++ b/src/xrGame/WeaponMagazined.cpp
@@ -1316,6 +1316,7 @@ bool CWeaponMagazined::Detach(const char* item_section_name, bool b_spawn_item)
 		return inherited::Detach(item_section_name, b_spawn_item);;
 }
 
+extern int scope_2dtexactive; //crookr
 void CWeaponMagazined::InitAddons()
 {
 	if (IsScopeAttached())
@@ -1332,6 +1333,7 @@ void CWeaponMagazined::InitAddons()
 			if (m_UIScope)
 			{
 				xr_delete(m_UIScope);
+				scope_2dtexactive = 0;//crookr
 			}
 
 			if (!g_dedicated_server && scope_tex_name != NULL)
@@ -1348,6 +1350,7 @@ void CWeaponMagazined::InitAddons()
 		if (m_eScopeStatus != ALife::eAddonPermanent && m_UIScope)
 		{
 			xr_delete(m_UIScope);
+			scope_2dtexactive = 0;//crookr
 		}
 		ResetScopeKoeffs();
 	}
diff --git a/src/xrGame/WeaponUpgrade.cpp b/src/xrGame/WeaponUpgrade.cpp
index 4b266c9..27af437 100644
--- a/src/xrGame/WeaponUpgrade.cpp
+++ b/src/xrGame/WeaponUpgrade.cpp
@@ -281,6 +281,10 @@ bool CWeapon::install_upgrade_addon(LPCSTR section, bool test)
 	result |= process_if_exists_set(section, "scope_alive_detector", &CInifile::r_string_wb,
 	                                m_zoom_params.m_sUseBinocularVision, test);
 
+	process_if_exists_set(section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Primary, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_alt", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Alt, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_gl", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_GL, test);
+
 	result |= result2;
 
 	temp_int = (int)m_eSilencerStatus;
diff --git a/src/xrGame/console_commands.cpp b/src/xrGame/console_commands.cpp
index 2841970..ff9c11a 100644
--- a/src/xrGame/console_commands.cpp
+++ b/src/xrGame/console_commands.cpp
@@ -60,6 +60,9 @@
 
 #include "..\..\xrEngine\x_ray.h"
 
+#include "NewZoomFlag.h"
+float n_zoom_step_count = 3.0f;
+
 string_path g_last_saved_game;
 
 #ifdef DEBUG
@@ -2512,4 +2515,16 @@ void CCC_RegisterCommands()
 		CMD4(CCC_Float, "g_streff", &streff, -10.f, 10.f);
 	//No need for server commands in a singleplayer-only mod
 	//register_mp_console_commands();
+    
+    zoomFlags.set(NEW_ZOOM, FALSE);
+    zoomFlags.set(SDS_ZOOM, TRUE);
+    zoomFlags.set(SDS_SPEED, TRUE);
+    zoomFlags.set(SDS, TRUE);
+
+    CMD3(CCC_Mask, "new_zoom_enable", &zoomFlags, NEW_ZOOM);
+    CMD3(CCC_Mask, "sds_zoom_enable", &zoomFlags, SDS_ZOOM);
+    CMD3(CCC_Mask, "sds_speed_enable", &zoomFlags, SDS_SPEED);
+    CMD3(CCC_Mask, "sds_enable", &zoomFlags, SDS);
+
+    CMD4(CCC_Float, "zoom_step_count", &n_zoom_step_count, 1.0f, 10.0f);
 }
diff --git a/src/xrGame/new_sds.h b/src/xrGame/new_sds.h
new file mode 100644
index 0000000..229a8a3
--- /dev/null
+++ b/src/xrGame/new_sds.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "map"
+#include "../xrCore/xrstring.h"
+
+std::map<shared_str, float> listScopeRadii;
\ No newline at end of file
diff --git a/src/xrGame/xrGame.vcxproj b/src/xrGame/xrGame.vcxproj
index c8e93f0..728e067 100644
--- a/src/xrGame/xrGame.vcxproj
+++ b/src/xrGame/xrGame.vcxproj
@@ -1228,6 +1228,8 @@
     <ClInclude Include="mt_config.h" />
     <ClInclude Include="Needles.h" />
     <ClInclude Include="NET_Queue.h" />
+    <ClInclude Include="NewZoomFlag.h" />
+    <ClInclude Include="new_sds.h" />
     <ClInclude Include="NoGravityZone.h" />
     <ClInclude Include="object_actions.h" />
     <ClInclude Include="object_actions_inline.h" />
diff --git a/src/xrServerEntities/script_engine_script.cpp b/src/xrServerEntities/script_engine_script.cpp
index 7f1edef..2d23b21 100644
--- a/src/xrServerEntities/script_engine_script.cpp
+++ b/src/xrServerEntities/script_engine_script.cpp
@@ -10,9 +10,14 @@
 #include "script_engine.h"
 #include "ai_space.h"
 #include "script_debugger.h"
+#include "new_sds.h"
 
 using namespace luabind;
 
+void AddScope(LPCSTR key, float val) {
+    listScopeRadii[key] = val;
+}
+
 void LuaLog1(LPCSTR caMessage)
 {
 #ifndef MASTER_GOLD
@@ -240,6 +245,7 @@ void CScriptEngine::script_register(lua_State* L)
 		def("user_name", &user_name),
 		def("time_global", &script_time_global),
 		def("time_global_async", &script_time_global_async),
+        def("add_scope_radii", &AddScope),
 #ifdef XRGAME_EXPORTS
 		def("device", &get_device),
 		def("is_enough_address_space_available", &is_enough_address_space_available_impl),
